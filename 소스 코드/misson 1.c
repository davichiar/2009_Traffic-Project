#pragma config(Sensor, S1,     left,                sensorLightActive)
#pragma config(Sensor, S2,     right,               sensorLightActive)
#pragma config(Sensor, S3,     sonar,               sensorSONAR)
#pragma config(Sensor, S4,     touch,               sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int left_t, right_t;
int count;

task main()
{
   nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
   nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;

   left_t = SensorValue[left] + 7;
   right_t = SensorValue[right] + 7;

   nMotorEncoder[motorA] = 0;
   while(nMotorEncoder[motorA] < 300)
   {
     motor[motorA] = 60;
     motor[motorC] = 60;
   }

   while(true)
   {
     if(SensorValue[left] > left_t && SensorValue[right] > right_t)
     {
       motor[motorA] = 60;
       motor[motorC] = 60;
     }
     else if(SensorValue[left] > left_t && SensorValue[right] < right_t)
     {
       motor[motorA] = 60;
       motor[motorC] = -100;
     }
     else if(SensorValue[left] < left_t && SensorValue[right] > right_t)
     {
       motor[motorA] = -100;
       motor[motorC] = 60;
     }
     else
     {
       if(count==8) break;
       else
       {
         motor[motorA] = 60;
         motor[motorC] = 60;
         wait1Msec(300);
       }
     }
   }

   nMotorEncoder[motorA] = 0;
   while(nMotorEncoder[motorA] < 300)
   {
     motor[motorA] = 60;
     motor[motorC] = 0;
   }

   while(true)
   {
     if(SensorValue[left] > left_t && SensorValue[right] > right_t)
     {
       motor[motorA] = 60;
       motor[motorC] = 60;
     }
     else if(SensorValue[left] > left_t && SensorValue[right] < right_t)
     {
       motor[motorA] = 60;
       motor[motorC] = -100;
     }
     else if(SensorValue[left] < left_t && SensorValue[right] > right_t)
     {
       motor[motorA] = -100;
       motor[motorC] = 60;
     }
     else
     {
       if(count==4) break;
       else
       {
         motor[motorA] = 60;
         motor[motorC] = 60;
         wait1Msec(300);
       }
     }
  }
  while(true)
   {
     if(SensorValue[left] > left_t && SensorValue[right] > right_t)
     {
       break;
     }
     else if(SensorValue[left] > left_t && SensorValue[right] < right_t)
     {
       motor[motorA] = 60;
       motor[motorC] = 10;
     }
     else if(SensorValue[left] < left_t && SensorValue[right] > right_t)
     {
       motor[motorA] = 10;
       motor[motorC] = 60;
     }
     else
     {
       motor[motorA] = 60;
       motor[motorC] = 60;
     }
  }

   count = 0;
   while(true)
   {
     if(SensorValue[left] < left_t)
     {
       break;
     }
     if(SensorValue[touch] == 1)
     {
       nMotorEncoder[motorA] = 0;
       while(nMotorEncoder[motorA] > -200)
       {
         motor[motorA] = -60;
         motor[motorC] = -60;
       }
       nMotorEncoder[motorA] = 0;
       while(nMotorEncoder[motorA] < 250)
       {
         motor[motorA] = 60;
         motor[motorC] = -60;
       }
     }
     if(SensorValue[sonar] < 4)
     {
       motor[motorA] = 60;
       motor[motorC] = 10;
     }
     else if(SensorValue[sonar] > 6)
     {
       motor[motorA] = 10;
       motor[motorC] = 60;
     }
     else
     {
       motor[motorA] = 60;
       motor[motorC] = 60;
     }
   }
}
